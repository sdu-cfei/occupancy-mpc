#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model MShootBS2019.ZoneCO2R2C2PID
 Dymola Version 2019 (64-bit), 2018-04-11 translated this at Mon May 27 08:20:21 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
#define NX_    9
#define NX2_   0
#define NU_    6
#define NY_    8
#define NW_    131
#define NP_    111
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ -1229093832
#define NHash2_ -590953294
#define NHash3_ -1136373413
#define NI_    0
#define NRelF_ 6
#define NRel_  6
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    135
#define SizePre_ 0
#define SizeEq_ 5
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="MShootBS2019.ZoneCO2R2C2PID";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/taoy/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
DYMOLA_STATIC const char*GUIDString="{398e4614-5eb8-4516-b5a6-5846d4ed383c}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[45]={6 , 4 , 1 , 2 , 3 , 4 , 1 , 5 , 1 , 6 , 1 , 7
   , 1 , 8 , 1 , 9 , 12 , 4 , 1 , 2 , 3 , 4 , 1 , 5 , 1 , 6 , 1 , 7 , 1 , 8 , 1
   , 9 , 1 , 10 , 1 , 11 , 1 , 12 , 1 , 13 , 1 , 14 , 1 , 15 , 0};
DYMOLA_STATIC int QJacobianGC_[259]={
1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 5 , 0 , 5 , 5 , 5 , 0 , 5 , 0 , 0 , 6 , 0 , 0
   , 0 , 0 , 6 , 0 , 0 , 0 , 7 , 0 , 7 , 7 , 7 , 0 , 7 , 0 , 0 , 8 , 8 , 0 , 0
   , 0 , 0 , 0 , 8 , 0 , 9 , 9 , 0 , 0 , 0 , 0 , 0 , 0 , 9 , 1 , 1 , 0 , 1 , 0
   , 1 , 0 , 1 , 1 , 1 , 2 , 3 , 0 , 1 , 1 , 4 , 0 , 5 , 0 , 5 , 5 , 5 , 0 , 5
   , 0 , 0 , 0 , 0 , 0 , 5 , 0 , 5 , 0 , 5 , 6 , 0 , 0 , 0 , 0 , 6 , 0 , 0 , 0
   , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 0 , 7 , 7 , 7 , 0 , 7 , 0 , 0 , 0 , 0
   , 0 , 7 , 0 , 7 , 0 , 0 , 8 , 8 , 0 , 0 , 0 , 0 , 0 , 8 , 0 , 0 , 0 , 0 , 0
   , 8 , 0 , 0 , 0 , 9 , 9 , 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , 0 , 0 , 0 , 9 , 0
   , 0 , 0 , 10 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
   , 11 , 0 , 0 , 11 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 11 , 0 , 0 , 12
   , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 13 , 0 , 13
   , 13 , 13 , 0 , 13 , 0 , 0 , 0 , 0 , 0 , 13 , 0 , 13 , 0 , 0 , 14 , 14 , 0 , 0
   , 0 , 0 , 0 , 14 , 0 , 0 , 0 , 0 , 0 , 14 , 0 , 0 , 0 , 15 , 15 , 0 , 0 , 0
   , 0 , 0 , 0 , 15 , 0 , 0 , 0 , 0 , 15 , 0 , 0 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[16]={0  , 44 , 55 , 66 , 77 , 80 , 81 , 80 , 77
   , 72 , 65 , 56 , 45 , 32 , 17 , 0};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_
#define DIRECT_FEED_THROUGH 1

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,10) = 1;
DYNX(W_,24) = 4;
DYNX(W_,52) = 2;
DYNX(W_,57) = 1;
DYNX(W_,68) = true;
DYNX(W_,69) = false;
DYNX(W_,79) = 2;
DYNX(W_,84) = 1;
DYNX(W_,95) = true;
DYNX(W_,96) = false;
DYNX(W_,106) = 2;
DYNX(W_,111) = 1;
DYNX(W_,122) = true;
DYNX(W_,123) = false;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,13) = 2;
DYNX(W_,28) = 3;
DYNX(W_,29) = 3;
DYNX(W_,36) = 3;
DYNX(W_,54) = 5;
DYNX(W_,55) = true;
DYNX(W_,56) = false;
DYNX(W_,66) = false;
DYNX(W_,67) = true;
DYNX(W_,71) = 3;
DYNX(W_,81) = 5;
DYNX(W_,82) = true;
DYNX(W_,83) = false;
DYNX(W_,93) = false;
DYNX(W_,94) = true;
DYNX(W_,98) = 3;
DYNX(W_,108) = 5;
DYNX(W_,109) = true;
DYNX(W_,110) = false;
DYNX(W_,120) = false;
DYNX(W_,121) = true;
DYNX(W_,125) = 3;
DYNX(W_,12) = false;
DYNX(W_,14) = 1;
DYNX(W_,3) = 0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,2) = divmacro(DYNX(DP_,0),"RExt",3*powmacro(DYNX(DP_,11),"Vi",
  0.6666666666666666,"0.6666666666666666"),"3*Vi^0.6666666666666666");
DYNX(W_,4) = DYNX(DP_,4);
DYNX(W_,20) = DYNX(DP_,7);
DYNX(W_,21) = 1005.0*DYNX(DP_,2)*1.2*DYNX(DP_,11);
DYNX(W_,30) = DYNX(DP_,12);
DYNX(W_,32) = DYNX(DP_,5);
DYNX(W_,35) = DYNX(DP_,6);
DYNX(W_,42) = DYNX(DP_,11);
DYNX(W_,39) = DYNX(W_,42);
DYNX(W_,41) = DYNX(DP_,8);
DYNX(W_,40) = DYNX(W_,41);
DYNX(W_,43) = DYNX(DP_,9);
DYNX(W_,44) = DYNX(W_,43);
DYNX(W_,45) = DYNX(DP_,10);
DYNX(W_,49) = divmacro(DYNX(DP_,1),"RInt",3*powmacro(DYNX(DP_,11),"Vi",
  0.6666666666666666,"0.6666666666666666"),"3*Vi^0.6666666666666666");
DYNX(W_,50) = 1005.0*DYNX(DP_,3)*1.2*DYNX(DP_,11);
DYNX(W_,53) = DYNX(DP_,13);
DYNX(W_,59) = DYNX(DP_,47);
DYNX(W_,61) = DYNX(W_,53);
DYNX(W_,64) = DYNX(DP_,45);
DYNX(W_,65) = DYNX(DP_,46);
DYNX(W_,70) = divmacro(1,"1",DYNX(DP_,43),"PIDco2.Ti");
DYNX(W_,72) = DYNX(DP_,51);
DYNX(W_,76) = divmacro(1,"1",DYNX(W_,53)*DYNX(DP_,49),"PIDco2.k*PIDco2.Ni");
DYNX(W_,80) = DYNX(DP_,14);
DYNX(W_,86) = DYNX(DP_,69);
DYNX(W_,88) = DYNX(W_,80);
DYNX(W_,91) = DYNX(DP_,67);
DYNX(W_,92) = DYNX(DP_,68);
DYNX(W_,97) = divmacro(1,"1",DYNX(DP_,65),"PIDt.Ti");
DYNX(W_,99) = DYNX(DP_,73);
DYNX(W_,103) = divmacro(1,"1",DYNX(W_,80)*DYNX(DP_,71),"PIDt.k*PIDt.Ni");
DYNX(W_,107) = DYNX(DP_,14);
DYNX(W_,113) = DYNX(DP_,91);
DYNX(W_,115) = DYNX(W_,107);
DYNX(W_,118) = DYNX(DP_,89);
DYNX(W_,119) = DYNX(DP_,90);
DYNX(W_,124) = divmacro(1,"1",DYNX(DP_,87),"PIDt1.Ti");
DYNX(W_,126) = DYNX(DP_,95);
DYNX(W_,130) = divmacro(1,"1",DYNX(W_,107)*DYNX(DP_,93),"PIDt1.k*PIDt1.Ni");
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", MetabolicHeat.table, MetabolicHeat.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,19), 2, 2, 2), IntegerTemporaryDense( 
    &DYNX(W_,13), 1, 1), 1, 0, 1));
  DYNX(W_,15) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(F_,0) = 0;
DYNX(F_,5) = 0;
DYNX(Y_,0) = 293.15;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,1) = DYNX(DP_,34);
DYNX(X_,2) = DYNX(DP_,36);
DYNX(X_,3) = DYNX(DP_,39);
DYNX(X_,6) = DYNX(W_,72);
DYNX(X_,7) = DYNX(W_,99);
DYNX(X_,8) = DYNX(W_,126);
DYNX(Y_,1) = DYNX(DP_,34);
DYNX(Y_,2) = DYNX(DP_,36);
DYNX(Y_,6) = DYNX(DP_,39);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,2) = divmacro(DYNX(DP_,0),"RExt",3*powmacro(DYNX(DP_,11),"Vi",
  0.6666666666666666,"0.6666666666666666"),"3*Vi^0.6666666666666666");
DYNX(W_,4) = DYNX(DP_,4);
DYNX(W_,20) = DYNX(DP_,7);
DYNX(W_,21) = 1005.0*DYNX(DP_,2)*1.2*DYNX(DP_,11);
DYNX(W_,30) = DYNX(DP_,12);
DYNX(W_,32) = DYNX(DP_,5);
DYNX(W_,35) = DYNX(DP_,6);
DYNX(W_,42) = DYNX(DP_,11);
DYNX(W_,39) = DYNX(W_,42);
DYNX(W_,41) = DYNX(DP_,8);
DYNX(W_,40) = DYNX(W_,41);
DYNX(W_,43) = DYNX(DP_,9);
DYNX(W_,44) = DYNX(W_,43);
DYNX(W_,45) = DYNX(DP_,10);
DYNX(W_,49) = divmacro(DYNX(DP_,1),"RInt",3*powmacro(DYNX(DP_,11),"Vi",
  0.6666666666666666,"0.6666666666666666"),"3*Vi^0.6666666666666666");
DYNX(W_,50) = 1005.0*DYNX(DP_,3)*1.2*DYNX(DP_,11);
DYNX(W_,53) = DYNX(DP_,13);
DYNX(W_,59) = DYNX(DP_,47);
DYNX(W_,61) = DYNX(W_,53);
DYNX(W_,64) = DYNX(DP_,45);
DYNX(W_,65) = DYNX(DP_,46);
AssertModelica(DYNX(W_,64) >= DYNX(W_,65),"PIDco2.limiter.uMax >= PIDco2.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,64), true, 0)),") < uMin (="),Real2String2(DYNX(W_,65), 
  true, 0)),")"));
PopAllMarks();
DYNX(W_,70) = divmacro(1,"1",DYNX(DP_,43),"PIDco2.Ti");
DYNX(W_,72) = DYNX(DP_,51);
DYNX(W_,76) = divmacro(1,"1",DYNX(W_,53)*DYNX(DP_,49),"PIDco2.k*PIDco2.Ni");
DYNX(W_,80) = DYNX(DP_,14);
DYNX(W_,86) = DYNX(DP_,69);
DYNX(W_,88) = DYNX(W_,80);
DYNX(W_,91) = DYNX(DP_,67);
DYNX(W_,92) = DYNX(DP_,68);
AssertModelica(DYNX(W_,91) >= DYNX(W_,92),"PIDt.limiter.uMax >= PIDt.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,91), true, 0)),") < uMin (="),Real2String2(DYNX(W_,92), 
  true, 0)),")"));
PopAllMarks();
DYNX(W_,97) = divmacro(1,"1",DYNX(DP_,65),"PIDt.Ti");
DYNX(W_,99) = DYNX(DP_,73);
DYNX(W_,103) = divmacro(1,"1",DYNX(W_,80)*DYNX(DP_,71),"PIDt.k*PIDt.Ni");
DYNX(W_,107) = DYNX(DP_,14);
DYNX(W_,113) = DYNX(DP_,91);
DYNX(W_,115) = DYNX(W_,107);
DYNX(W_,118) = DYNX(DP_,89);
DYNX(W_,119) = DYNX(DP_,90);
AssertModelica(DYNX(W_,118) >= DYNX(W_,119),"PIDt1.limiter.uMax >= PIDt1.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,118), true, 0)),") < uMin (="),Real2String2(DYNX(W_,119),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,124) = divmacro(1,"1",DYNX(DP_,87),"PIDt1.Ti");
DYNX(W_,126) = DYNX(DP_,95);
DYNX(W_,130) = divmacro(1,"1",DYNX(W_,107)*DYNX(DP_,93),"PIDt1.k*PIDt1.Ni");
DYNX(W_,16) = 0.0;
  {
    DYNX(W_,16) = 1.0;
  }
DYNX(X_,6) = DYNX(W_,72);
DYNX(X_,8) = DYNX(W_,126);
DYNX(X_,7) = DYNX(W_,99);
DYNX(X_,1) = DYNX(DP_,34);
DYNX(X_,2) = DYNX(DP_,36);
DYNX(X_,3) = DYNX(DP_,39);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", MetabolicHeat.table, MetabolicHeat.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,19), 2, 2, 2), IntegerTemporaryDense( 
    &DYNX(W_,13), 1, 1), 1, 0, 1));
  DYNX(W_,15) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection2
DYNX(W_,58) = DYNX(W_,59)*DYNX(U_,3)+DYNX(DP_,54)*DYNX(X_,4);
DYNX(W_,60) = DYNX(DP_,55)*DYNX(W_,58);
DYNX(W_,62) = DYNX(DP_,56)*DYNX(W_,60)+DYNX(DP_,57)*DYNX(DP_,59)+DYNX(DP_,58)*
  DYNX(X_,6);
DYNX(W_,63) = DYNX(W_,61)*DYNX(W_,62);
DYNX(W_,34) = homotopy(IF GreaterS(DYNX(W_,63),"PIDco2.gainPID.y", DYNX(W_,64),
  "PIDco2.limiter.uMax", 0) THEN DYNX(W_,64) ELSE IF LessS(DYNX(W_,63),
  "PIDco2.gainPID.y", DYNX(W_,65),"PIDco2.limiter.uMin", 1) THEN DYNX(W_,65)
   ELSE DYNX(W_,63), DYNX(W_,63));
DYNX(W_,85) = DYNX(W_,86)*DYNX(U_,4)+DYNX(DP_,76)*DYNX(X_,0);
DYNX(W_,87) = DYNX(DP_,77)*DYNX(W_,85);
DYNX(W_,89) = DYNX(DP_,78)*DYNX(W_,87)+DYNX(DP_,79)*DYNX(DP_,81)+DYNX(DP_,80)*
  DYNX(X_,7);
DYNX(W_,90) = DYNX(W_,88)*DYNX(W_,89);
DYNX(W_,77) = homotopy(IF GreaterS(DYNX(W_,90),"PIDt.gainPID.y", DYNX(W_,91),
  "PIDt.limiter.uMax", 2) THEN DYNX(W_,91) ELSE IF LessS(DYNX(W_,90),
  "PIDt.gainPID.y", DYNX(W_,92),"PIDt.limiter.uMin", 3) THEN DYNX(W_,92) ELSE 
  DYNX(W_,90), DYNX(W_,90));
DYNX(W_,112) = DYNX(W_,113)*DYNX(U_,5)+DYNX(DP_,98)*DYNX(X_,0);
DYNX(W_,114) = DYNX(DP_,99)*DYNX(W_,112);
DYNX(W_,116) = DYNX(DP_,100)*DYNX(W_,114)+DYNX(DP_,101)*DYNX(DP_,103)+
  DYNX(DP_,102)*DYNX(X_,8);
DYNX(W_,117) = DYNX(W_,115)*DYNX(W_,116);
DYNX(W_,104) = homotopy(IF GreaterS(DYNX(W_,117),"PIDt1.gainPID.y", DYNX(W_,118),
  "PIDt1.limiter.uMax", 4) THEN DYNX(W_,118) ELSE IF LessS(DYNX(W_,117),
  "PIDt1.gainPID.y", DYNX(W_,119),"PIDt1.limiter.uMin", 5) THEN DYNX(W_,119)
   ELSE DYNX(W_,117), DYNX(W_,117));
InitialSection
InitialSection2
DYNX(Y_,0) = DYNX(X_,0);
DYNX(Y_,1) = DYNX(X_,1);
DYNX(Y_,2) = DYNX(X_,2);
DYNX(W_,31) = DYNX(DP_,37)*DYNX(W_,34);
DYNX(Y_,3) = DYNX(W_,30)*DYNX(W_,31);
DYNX(W_,37) = DYNX(DP_,109)*DYNX(W_,77)+DYNX(DP_,110)*DYNX(W_,104);
DYNX(W_,33) = DYNX(DP_,40)*DYNX(W_,37);
DYNX(W_,19) = DYNX(W_,32)*DYNX(W_,33);
DYNX(Y_,4) = DYNX(W_,19)*(1+DYNX(DP_,25)*(DYNX(X_,0)-DYNX(DP_,24)));
DYNX(W_,26) = RealBmax(DYNX(U_,1), DYNX(W_,35));
DYNX(W_,23) = DYNX(DP_,28)*DYNX(X_,0)+DYNX(DP_,29)*DYNX(W_,26);
DYNX(W_,25) = DYNX(DP_,26)*DYNX(DP_,27)*DYNX(W_,23)*DYNX(Y_,3);
DYNX(Y_,5) = DYNX(W_,25)*(1+DYNX(DP_,32)*(DYNX(X_,0)-DYNX(DP_,31)));
DYNX(Y_,6) = DYNX(X_,3);
DYNX(Y_,7) = DYNX(X_,4);
DYNX(W_,38) = DYNX(DP_,41)*DYNX(W_,45)+DYNX(DP_,42)*DYNX(Y_,3);
 /* Linear system of equations to solve. */
DYNX(F_,4) = 0.0;
SolveScalarLinear(3600.0*DYNX(W_,39),"3600.0*co2.balance.Vi", 1000000.0*
  DYNX(U_,2)*DYNX(W_,40)+DYNX(W_,38)*(DYNX(W_,44)-DYNX(X_,4)),"1000000.0*(occ*co2.CO2Generation.k)+co2.Vve*(co2.CO2NeutralLevel.k-co2.balance.CO2ppmv_i)",
   DYNX(F_,4),"der(co2.balance.CO2ppmv_i)");
 /* End of Equation Block */ 

DYNX(W_,75) = DYNX(DP_,63)*DYNX(W_,34)+DYNX(DP_,64)*DYNX(W_,63);
DYNX(W_,74) = DYNX(W_,76)*DYNX(W_,75);
DYNX(W_,73) = DYNX(DP_,60)*DYNX(U_,3)+DYNX(DP_,61)*DYNX(X_,4)+DYNX(DP_,62)*
  DYNX(W_,74);
DYNX(F_,6) = DYNX(W_,70)*DYNX(W_,73);
DYNX(W_,129) = DYNX(DP_,107)*DYNX(W_,104)+DYNX(DP_,108)*DYNX(W_,117);
DYNX(W_,128) = DYNX(W_,130)*DYNX(W_,129);
DYNX(W_,127) = DYNX(DP_,104)*DYNX(U_,5)+DYNX(DP_,105)*DYNX(X_,0)+DYNX(DP_,106)*
  DYNX(W_,128);
DYNX(F_,8) = DYNX(W_,124)*DYNX(W_,127);
DYNX(W_,102) = DYNX(DP_,85)*DYNX(W_,77)+DYNX(DP_,86)*DYNX(W_,90);
DYNX(W_,101) = DYNX(W_,103)*DYNX(W_,102);
DYNX(W_,100) = DYNX(DP_,82)*DYNX(U_,4)+DYNX(DP_,83)*DYNX(X_,0)+DYNX(DP_,84)*
  DYNX(W_,101);
DYNX(F_,7) = DYNX(W_,97)*DYNX(W_,100);
DYNX(W_,11) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nMetabolicHeat.tableID, \n1, \ncair.T, \nMetabolicHeat.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15))), 1, DYNX(X_,0), DYNX(W_,16)));
PopModelContext();
DYNX(W_,7) = DYNX(W_,20)*DYNX(W_,11);
DYNX(W_,8) = DYNX(U_,2)*DYNX(W_,7);
DYNX(W_,9) =  -DYNX(W_,8)*(1+DYNX(DP_,18)*(DYNX(X_,0)-DYNX(DP_,17)));
DYNX(W_,5) = DYNX(W_,4)*DYNX(U_,0);
DYNX(W_,6) =  -DYNX(W_,5)*(1+DYNX(DP_,16)*(DYNX(X_,0)-DYNX(DP_,15)));
DYNX(W_,1) = DYNX(U_,1)-DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(W_,0) = 0.0;
SolveScalarLinear( -DYNX(W_,2)," -re.R",  -DYNX(W_,1)," -re.dT", DYNX(W_,0),
  "re.Q_flow");
 /* End of Equation Block */ 

DYNX(W_,47) = DYNX(X_,0)-DYNX(X_,5);
 /* Linear system of equations to solve. */
DYNX(W_,46) = 0.0;
SolveScalarLinear( -DYNX(W_,49)," -re1.R",  -DYNX(W_,47)," -re1.dT", DYNX(W_,46),
  "re1.Q_flow");
 /* End of Equation Block */ 

DYNX(W_,22) =  -(DYNX(W_,9)-(DYNX(Y_,4)+DYNX(Y_,5))+DYNX(W_,6)-DYNX(W_,0)+
  DYNX(W_,46));
 /* Linear system of equations to solve. */
DYNX(F_,0) = 0;
SolveScalarLinear(DYNX(W_,21),"cair.C", DYNX(W_,22),"cair.port.Q_flow", 
  DYNX(F_,0),"der(cair.T)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(F_,5) = 0;
SolveScalarLinear(DYNX(W_,50),"cint.C", DYNX(W_,46),"re1.Q_flow", DYNX(F_,5),
  "der(cint.T)");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(DP_,33)*DYNX(Y_,4);
DYNX(F_,2) = DYNX(DP_,35)*DYNX(Y_,3);
DYNX(F_,3) = DYNX(DP_,38)*DYNX(Y_,5);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(Y_,0) = DYNX(X_,0);
DYNX(Y_,1) = DYNX(X_,1);
DYNX(Y_,2) = DYNX(X_,2);
DYNX(Y_,6) = DYNX(X_,3);
DYNX(Y_,7) = DYNX(X_,4);
DYNX(W_,58) = DYNX(W_,59)*DYNX(U_,3)+DYNX(DP_,54)*DYNX(X_,4);
DYNX(W_,60) = DYNX(DP_,55)*DYNX(W_,58);
DYNX(W_,62) = DYNX(DP_,56)*DYNX(W_,60)+DYNX(DP_,57)*DYNX(DP_,59)+DYNX(DP_,58)*
  DYNX(X_,6);
DYNX(W_,63) = DYNX(W_,61)*DYNX(W_,62);
DYNX(W_,34) = IF GreaterS(DYNX(W_,63),"PIDco2.gainPID.y", DYNX(W_,64),
  "PIDco2.limiter.uMax", 0) THEN DYNX(W_,64) ELSE IF LessS(DYNX(W_,63),
  "PIDco2.gainPID.y", DYNX(W_,65),"PIDco2.limiter.uMin", 1) THEN DYNX(W_,65)
   ELSE DYNX(W_,63);
DYNX(W_,31) = DYNX(DP_,37)*DYNX(W_,34);
DYNX(Y_,3) = DYNX(W_,30)*DYNX(W_,31);
DYNX(W_,85) = DYNX(W_,86)*DYNX(U_,4)+DYNX(DP_,76)*DYNX(X_,0);
DYNX(W_,87) = DYNX(DP_,77)*DYNX(W_,85);
DYNX(W_,89) = DYNX(DP_,78)*DYNX(W_,87)+DYNX(DP_,79)*DYNX(DP_,81)+DYNX(DP_,80)*
  DYNX(X_,7);
DYNX(W_,90) = DYNX(W_,88)*DYNX(W_,89);
DYNX(W_,77) = IF GreaterS(DYNX(W_,90),"PIDt.gainPID.y", DYNX(W_,91),
  "PIDt.limiter.uMax", 2) THEN DYNX(W_,91) ELSE IF LessS(DYNX(W_,90),
  "PIDt.gainPID.y", DYNX(W_,92),"PIDt.limiter.uMin", 3) THEN DYNX(W_,92) ELSE 
  DYNX(W_,90);
DYNX(W_,112) = DYNX(W_,113)*DYNX(U_,5)+DYNX(DP_,98)*DYNX(X_,0);
DYNX(W_,114) = DYNX(DP_,99)*DYNX(W_,112);
DYNX(W_,116) = DYNX(DP_,100)*DYNX(W_,114)+DYNX(DP_,101)*DYNX(DP_,103)+
  DYNX(DP_,102)*DYNX(X_,8);
DYNX(W_,117) = DYNX(W_,115)*DYNX(W_,116);
DYNX(W_,104) = IF GreaterS(DYNX(W_,117),"PIDt1.gainPID.y", DYNX(W_,118),
  "PIDt1.limiter.uMax", 4) THEN DYNX(W_,118) ELSE IF LessS(DYNX(W_,117),
  "PIDt1.gainPID.y", DYNX(W_,119),"PIDt1.limiter.uMin", 5) THEN DYNX(W_,119)
   ELSE DYNX(W_,117);
DYNX(W_,37) = DYNX(DP_,109)*DYNX(W_,77)+DYNX(DP_,110)*DYNX(W_,104);
DYNX(W_,33) = DYNX(DP_,40)*DYNX(W_,37);
DYNX(W_,19) = DYNX(W_,32)*DYNX(W_,33);
DYNX(Y_,4) = DYNX(W_,19)*(1+DYNX(DP_,25)*(DYNX(X_,0)-DYNX(DP_,24)));
DYNX(W_,26) = RealBmax(DYNX(U_,1), DYNX(W_,35));
DYNX(W_,23) = DYNX(DP_,28)*DYNX(X_,0)+DYNX(DP_,29)*DYNX(W_,26);
DYNX(W_,25) = DYNX(DP_,26)*DYNX(DP_,27)*DYNX(W_,23)*DYNX(Y_,3);
DYNX(Y_,5) = DYNX(W_,25)*(1+DYNX(DP_,32)*(DYNX(X_,0)-DYNX(DP_,31)));
DYNX(W_,27) =  -DYNX(Y_,5);
DYNX(W_,18) =  -DYNX(Y_,4);

DynamicsSection
DYNX(W_,38) = DYNX(DP_,41)*DYNX(W_,45)+DYNX(DP_,42)*DYNX(Y_,3);
 /* Linear system of equations to solve. */
DYNX(F_,4) = RememberSimple_(DYNX(F_,4), 0);
SolveScalarLinearParametric(3600.0*DYNX(W_,39),"3600.0*co2.balance.Vi", 
  1000000.0*DYNX(U_,2)*DYNX(W_,40)+DYNX(W_,38)*(DYNX(W_,44)-DYNX(X_,4)),
  "1000000.0*(occ*co2.CO2Generation.k)+co2.Vve*(co2.CO2NeutralLevel.k-co2.balance.CO2ppmv_i)",
   DYNX(F_,4),"der(co2.balance.CO2ppmv_i)");
 /* End of Equation Block */ 

DYNX(W_,75) = DYNX(DP_,63)*DYNX(W_,34)+DYNX(DP_,64)*DYNX(W_,63);
DYNX(W_,74) = DYNX(W_,76)*DYNX(W_,75);
DYNX(W_,73) = DYNX(DP_,60)*DYNX(U_,3)+DYNX(DP_,61)*DYNX(X_,4)+DYNX(DP_,62)*
  DYNX(W_,74);
DYNX(F_,6) = DYNX(W_,70)*DYNX(W_,73);
DYNX(W_,129) = DYNX(DP_,107)*DYNX(W_,104)+DYNX(DP_,108)*DYNX(W_,117);
DYNX(W_,128) = DYNX(W_,130)*DYNX(W_,129);
DYNX(W_,127) = DYNX(DP_,104)*DYNX(U_,5)+DYNX(DP_,105)*DYNX(X_,0)+DYNX(DP_,106)*
  DYNX(W_,128);
DYNX(F_,8) = DYNX(W_,124)*DYNX(W_,127);
DYNX(W_,102) = DYNX(DP_,85)*DYNX(W_,77)+DYNX(DP_,86)*DYNX(W_,90);
DYNX(W_,101) = DYNX(W_,103)*DYNX(W_,102);
DYNX(W_,100) = DYNX(DP_,82)*DYNX(U_,4)+DYNX(DP_,83)*DYNX(X_,0)+DYNX(DP_,84)*
  DYNX(W_,101);
DYNX(F_,7) = DYNX(W_,97)*DYNX(W_,100);
DYNX(W_,11) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nMetabolicHeat.tableID, \n1, \ncair.T, \nMetabolicHeat.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,15))), 1, DYNX(X_,0), DYNX(W_,16)));
PopModelContext();
DYNX(W_,7) = DYNX(W_,20)*DYNX(W_,11);
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,8) = DYNX(U_,2)*DYNX(W_,7);
DYNX(W_,9) =  -DYNX(W_,8)*(1+DYNX(DP_,18)*(DYNX(X_,0)-DYNX(DP_,17)));
DYNX(W_,5) = DYNX(W_,4)*DYNX(U_,0);
DYNX(W_,6) =  -DYNX(W_,5)*(1+DYNX(DP_,16)*(DYNX(X_,0)-DYNX(DP_,15)));
DYNX(W_,1) = DYNX(U_,1)-DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(W_,0) = RememberSimple_(DYNX(W_,0), 1);
SolveScalarLinearParametric( -DYNX(W_,2)," -re.R",  -DYNX(W_,1)," -re.dT", 
  DYNX(W_,0),"re.Q_flow");
 /* End of Equation Block */ 

DYNX(W_,47) = DYNX(X_,0)-DYNX(X_,5);
 /* Linear system of equations to solve. */
DYNX(W_,46) = RememberSimple_(DYNX(W_,46), 2);
SolveScalarLinearParametric( -DYNX(W_,49)," -re1.R",  -DYNX(W_,47)," -re1.dT", 
  DYNX(W_,46),"re1.Q_flow");
 /* End of Equation Block */ 

DYNX(W_,22) =  -(DYNX(W_,9)-(DYNX(Y_,4)+DYNX(Y_,5))+DYNX(W_,6)-DYNX(W_,0)+
  DYNX(W_,46));
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 3);
SolveScalarLinearParametric(DYNX(W_,21),"cair.C", DYNX(W_,22),"cair.port.Q_flow",
   DYNX(F_,0),"der(cair.T)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(F_,5) = RememberSimple_(DYNX(F_,5), 4);
SolveScalarLinearParametric(DYNX(W_,50),"cint.C", DYNX(W_,46),"re1.Q_flow", 
  DYNX(F_,5),"der(cint.T)");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(DP_,33)*DYNX(Y_,4);
DYNX(F_,2) = DYNX(DP_,35)*DYNX(Y_,3);
DYNX(F_,3) = DYNX(DP_,38)*DYNX(Y_,5);
DYNX(W_,17) =  -DYNX(W_,0);
DYNX(W_,48) =  -DYNX(W_,46);

AcceptedSection1

AcceptedSection2
DYNX(W_,51) = DYNX(U_,3)-DYNX(X_,4);
DYNX(W_,78) = DYNX(U_,4)-DYNX(X_,0);
DYNX(W_,105) = DYNX(U_,5)-DYNX(X_,0);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("RExt", "External wall thermal resistance", 0, 1.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("RInt", "Internal wall thermal resistance", 1, 1.0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("tmass", "Zone thermal mass factor [-] []", 2, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("imass", "Zone internal thermal mass factor [-] []", 3, 10, \
0.0,0.0,0.0,0,560)
DeclareParameter("shgc", "Solar heat gain coefficient [-] [1]", 4, 0.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("maxHeat", "Heating power of radiators [W] [1]", 5, 5000, \
0.0,0.0,0.0,0,560)
DeclareParameter("Tve", "Ventilation air temperature", 6, 21, 0.0,0.0,0.0,0,560)
DeclareParameter("occheff", "Occupant heat generation effectiveness [1]", 7, 1.0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("CO2pp", "CO2 generation per person [m3/h] []", 8, 0.02, \
0.0,0.0,0.0,0,560)
DeclareParameter("CO2n", "CO2 Neutral Level", 9, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("Vinf", "Infiltration flow rate [m3/h] []", 10, 100, 0.0,0.0,\
0.0,0,560)
DeclareParameter("Vi", "Air volume [m3] []", 11, 300, 0.0,0.0,0.0,0,560)
DeclareParameter("maxVent", "Maximum ventilation flowrate [m3/h] [1]", 12, 2000,\
 0.0,0.0,0.0,0,560)
DeclareParameter("kco2", "Gain of CO2 controller [1]", 13, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("kt", "Gain of temperature controller [1]", 14, 100, 0.0,0.0,\
0.0,0,560)
DeclareInput("solrad", "Solar radiation [W] [:#(prefix=input)]", 0, 0.0, \
0.0,0.0,0.0,0,512)
DeclareInput("Tout", "Outdoor temperature [degC] [K:#(prefix=input)]", 1, 288.15,\
 0.0,1E+100,300.0,0,512)
DeclareOutput("T", "[K] [K]", 0, 293.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("re.Q_flow", "Heat flow rate from port_a -> port_b [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("re.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("re.port_a.T", "Port temperature [K|degC]", "Tout", 1, 2, 1, 4)
DeclareAlias2("re.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "re.Q_flow", 1, 5, 0, 132)
DeclareAlias2("re.port_b.T", "Port temperature [K|degC]", "cair.T", 1, 1, 0, 4)
DeclareAlias2("re.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "prescribedTemperature.port.Q_flow", 1, 5, 17, 132)
DeclareVariable("re.R", "Constant thermal resistance of material [K/W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("temperatureSensor.T", "Absolute temperature as output signal [K]",\
 "cair.T", 1, 1, 0, 0)
DeclareAlias2("temperatureSensor.port.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareVariable("temperatureSensor.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("solarCoeff.k", "Gain value multiplied with input signal [1]", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("solarCoeff.u", "Input signal connector", "solrad", 1, 2, 0, 0)
DeclareVariable("solarCoeff.y", "Output signal connector [W]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareParameter("prescribedHeatFlow.T_ref", "Reference temperature [K|degC]", 15,\
 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("prescribedHeatFlow.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 16, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("prescribedHeatFlow.Q_flow", "[W]", "solarCoeff.y", 1, 5, 5, 0)
DeclareAlias2("prescribedHeatFlow.port.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareVariable("prescribedHeatFlow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("hmltp.u1", "Connector of Real input signal 1", "occ", 1, 2, 2, 0)
DeclareVariable("hmltp.u2", "Connector of Real input signal 2", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("hmltp.y", "Connector of Real output signal [W]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("occHeatGain.T_ref", "Reference temperature [K|degC]", 17, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("occHeatGain.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 18, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("occHeatGain.Q_flow", "[W]", "hmltp.y", 1, 5, 8, 0)
DeclareAlias2("occHeatGain.port.T", "Port temperature [K|degC]", "cair.T", 1, 1,\
 0, 4)
DeclareVariable("occHeatGain.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("MetabolicHeat.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("MetabolicHeat.u[1]", "Connector of Real input signals [K]", \
"cair.T", 1, 1, 0, 0)
DeclareVariable("MetabolicHeat.y[1]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("MetabolicHeat.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("MetabolicHeat.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 19, 293.15, 0.0,0.0,0.0,0,560)
DeclareParameter("MetabolicHeat.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 20, 84.0, 0.0,0.0,0.0,0,560)
DeclareParameter("MetabolicHeat.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 21, 325.15, 0.0,0.0,0.0,0,560)
DeclareParameter("MetabolicHeat.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 22, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("MetabolicHeat.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 23, true, 0.0,0.0,0.0,0,562)
DeclareVariable("MetabolicHeat.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("MetabolicHeat.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("MetabolicHeat.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("MetabolicHeat.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("prescribedTemperature.port.T", "Port temperature [K|degC]", \
"Tout", 1, 2, 1, 4)
DeclareVariable("prescribedTemperature.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("prescribedTemperature.T", "[K]", "Tout", 1, 2, 1, 0)
DeclareAlias2("heatFlowSensor.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "qr", 1, 3, 4, 0)
DeclareAlias2("heatFlowSensor.port_a.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareAlias2("heatFlowSensor.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "qr", 1, 3, 4, 132)
DeclareAlias2("heatFlowSensor.port_b.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareVariable("heatFlowSensor.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareOutput("Qr", "Heat supplied by radiators [Wh] [J]", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("prescribedHeatFlow1.T_ref", "Reference temperature [K|degC]", 24,\
 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("prescribedHeatFlow1.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 25, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("prescribedHeatFlow1.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("prescribedHeatFlow1.port.T", "Port temperature [K|degC]", \
"cair.T", 1, 1, 0, 4)
DeclareAlias2("prescribedHeatFlow1.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "heatFlowSensor.port_b.Q_flow", 1, 5, 18, 132)
DeclareVariable("occeffectiv.k", "Gain value multiplied with input signal [1]", 1,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("occeffectiv.u", "Input signal connector", "MetabolicHeat.y[1]", 1,\
 5, 11, 0)
DeclareAlias2("occeffectiv.y", "Output signal connector", "hmltp.u2", 1, 5, 7, 0)
DeclareVariable("cair.C", "Heat capacity of element (= cp*m) [J/K]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareState("cair.T", "Temperature of element [K|degC]", 0, 293.15, 0.0,1E+100,\
300.0,0,560)
DeclareDerivative("cair.der(T)", "der(Temperature of element) [K/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("cair.der_T", "Time derivative of temperature (= der(T)) [K/s]", \
"cair.der(T)", 1, 6, 0, 0)
DeclareAlias2("cair.port.T", "Port temperature [K|degC]", "cair.T", 1, 1, 0, 4)
DeclareVariable("cair.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("airMix.h_to_s.k", "Constant output value", 26, \
0.0002777777777777778, 0.0,0.0,0.0,0,560)
DeclareAlias2("airMix.h_to_s.y", "Connector of Real output signal", \
"airMix.h_to_s.k", 1, 7, 26, 0)
DeclareParameter("airMix.AirRhoCp.k", "Constant output value", 27, 1206.0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("airMix.AirRhoCp.y", "Connector of Real output signal", \
"airMix.AirRhoCp.k", 1, 7, 27, 0)
DeclareAlias2("airMix.add.u1", "Connector of Real input signal 1 [K]", "cair.T", 1,\
 1, 0, 0)
DeclareAlias2("airMix.add.u2", "Connector of Real input signal 2 [K]", \
"airMix.Tve", 1, 5, 26, 0)
DeclareVariable("airMix.add.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("airMix.add.k1", "Gain of upper input", 28, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("airMix.add.k2", "Gain of lower input", 29, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("airMix.multiProduct.significantDigits", "Number of significant digits to be shown in dynamic diagram layer for y [:#(type=Integer)]",\
 30, 8, 1.0,1E+100,0.0,0,564)
DeclareVariable("airMix.multiProduct.nu", "Number of input connections [:#(type=Integer)]",\
 4, 0.0,1E+100,0.0,0,1541)
DeclareAlias2("airMix.multiProduct.u[1]", "", "airMix.h_to_s.k", 1, 7, 26, 0)
DeclareAlias2("airMix.multiProduct.u[2]", "", "airMix.AirRhoCp.k", 1, 7, 27, 0)
DeclareAlias2("airMix.multiProduct.u[3]", "", "airMix.add.y", 1, 5, 23, 0)
DeclareAlias2("airMix.multiProduct.u[4]", "", "ve", 1, 3, 3, 0)
DeclareVariable("airMix.multiProduct.y", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("airMix.Tve", "[K]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("airMix.Ti", "[K]", "cair.T", 1, 1, 0, 0)
DeclareAlias2("airMix.Vve", "[m3/h] []", "ve", 1, 3, 3, 0)
DeclareParameter("airMix.prescribedHeatFlow.T_ref", "Reference temperature [K|degC]",\
 31, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("airMix.prescribedHeatFlow.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 32, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("airMix.prescribedHeatFlow.Q_flow", "[W]", "airMix.multiProduct.y", 1,\
 5, 25, 0)
DeclareAlias2("airMix.prescribedHeatFlow.port.T", "Port temperature [K|degC]", \
"cair.T", 1, 1, 0, 4)
DeclareAlias2("airMix.prescribedHeatFlow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "airMix.port_b.Q_flow", 1, 5, 27, 132)
DeclareAlias2("airMix.port_b.T", "Port temperature [K|degC]", "cair.T", 1, 1, 0,\
 4)
DeclareVariable("airMix.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("integrator.k", "Integrator gain [1]", 33, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("integrator.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("integrator.y_start", "Initial or guess value of output (= state) [J]",\
 34, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("integrator.u", "Connector of Real input signal [W]", "qr", 1, 3, 4,\
 0)
DeclareState("integrator.y", "Connector of Real output signal [J]", 1, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("integrator.der(y)", "der(Connector of Real output signal) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("occ", "Number of occupants [:#(prefix=input)]", 2, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareOutput("vetot", "Total airflow supply [m3] []", 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("integrator1.k", "Integrator gain [1]", 35, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("integrator1.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("integrator1.y_start", "Initial or guess value of output (= state)",\
 36, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("integrator1.u", "Connector of Real input signal", "ve", 1, 3, 3, 0)
DeclareState("integrator1.y", "Connector of Real output signal", 2, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("integrator1.der(y)", "der(Connector of Real output signal)", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("max1.u1", "Connector of Real input signal 1 [K]", "Tout", 1, 2, 1,\
 0)
DeclareAlias2("max1.u2", "Connector of Real input signal 2", "const2.k", 1, 5, 35,\
 0)
DeclareAlias2("max1.y", "Connector of Real output signal [K]", "airMix.Tve", 1, 5,\
 26, 0)
DeclareVariable("ventilation.k", "Gain value multiplied with input signal [1]", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("ventilation.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("ventilation.y", "Output signal connector", "ve", 1, 3, 3, 0)
DeclareVariable("heating.k", "Gain value multiplied with input signal [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("heating.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("heating.y", "Output signal connector [W]", "prescribedHeatFlow1.Q_flow", 1,\
 5, 19, 0)
DeclareOutput("ve", "Ventilation airflow rate [m3/h] []", 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("qr", "Heat supply by radiators [W] [W]", 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("scale.k", "Gain value multiplied with input signal [1]", 37, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("scale.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("scale.y", "Output signal connector", "ventilation.u", 1, 5, 31, 0)
DeclareInput("CO2stp", "CO2 setpoint [ppm] [:#(prefix=input)]", 3, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("const2.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("const2.y", "Connector of Real output signal", "const2.k", 1, 5, 35,\
 0)
DeclareInput("Tstp_cooling", "Indoor temperature setpoint [degC] [K:#(prefix=input)]",\
 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("heatFlowSensor1.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "qv", 1, 3, 5, 0)
DeclareAlias2("heatFlowSensor1.port_a.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareAlias2("heatFlowSensor1.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "qv", 1, 3, 5, 132)
DeclareAlias2("heatFlowSensor1.port_b.T", "Port temperature [K|degC]", "cair.T", 1,\
 1, 0, 4)
DeclareAlias2("heatFlowSensor1.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "airMix.port_b.Q_flow", 1, 5, 27, 132)
DeclareOutput("qv", "Ventilation heat load [W] [W]", 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("integrator2.k", "Integrator gain [1]", 38, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("integrator2.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("integrator2.y_start", "Initial or guess value of output (= state) [J]",\
 39, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("integrator2.u", "Connector of Real input signal [W]", "qv", 1, 3,\
 5, 0)
DeclareState("integrator2.y", "Connector of Real output signal [J]", 3, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("integrator2.der(y)", "der(Connector of Real output signal) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("Qv", "Ventilation heat load [Wh] [J]", 6, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("scale1.k", "Gain value multiplied with input signal [1]", 40, \
0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("scale1.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("scale1.y", "Output signal connector", "heating.u", 1, 5, 33, 0)
DeclareVariable("co2.Vve", "[m3/h] []", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("co2.CO2", "", "co2.balance.CO2ppmv_i", 1, 1, 4, 0)
DeclareAlias2("co2.balance.Vve", "Ventilation air flow rate [m3/h] []", \
"co2.Vve", 1, 5, 38, 0)
DeclareAlias2("co2.balance.CO2ppmv_s", "CO2 concentration in incoming air [ppmv] []",\
 "co2.CO2NeutralLevel.k", 1, 5, 44, 0)
DeclareAlias2("co2.balance.persons", "Number of persons", "occ", 1, 2, 2, 0)
DeclareAlias2("co2.balance.CO2_per_person", "CO2 generation per person [ppmv/h] []",\
 "co2.CO2Generation.k", 1, 5, 40, 0)
DeclareAlias2("co2.balance.CO2output", "", "co2.balance.CO2ppmv_i", 1, 1, 4, 0)
DeclareVariable("co2.balance.Vi", "Indoor volume [m3] []", 0.0, 0.0,0.0,0.0,0,513)
DeclareState("co2.balance.CO2ppmv_i", "CO2 indoor concentration [ppmv] []", 4, \
0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("co2.balance.der(CO2ppmv_i)", "der(CO2 indoor concentration [ppmv])",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("co2.persons", "", "occ", 1, 2, 2, 0)
DeclareVariable("co2.CO2Generation.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("co2.CO2Generation.y", "Connector of Real output signal", \
"co2.CO2Generation.k", 1, 5, 40, 0)
DeclareVariable("co2.CO2PerPerson", "CO2 generation per person [m3/h] []", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("co2.Vi", "Indoor volume [m3] []", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("co2.CO2Neutral", "CO2 Neutral Level", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("co2.CO2NeutralLevel.k", "Constant output value", 1, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("co2.CO2NeutralLevel.y", "Connector of Real output signal", \
"co2.CO2NeutralLevel.k", 1, 5, 44, 0)
DeclareVariable("const1.k", "Constant output value", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("const1.y", "Connector of Real output signal", "const1.k", 1, 5, 45,\
 0)
DeclareAlias2("add.u1", "Connector of Real input signal 1", "const1.k", 1, 5, 45,\
 0)
DeclareAlias2("add.u2", "Connector of Real input signal 2", "ve", 1, 3, 3, 0)
DeclareAlias2("add.y", "Connector of Real output signal", "co2.Vve", 1, 5, 38, 0)
DeclareParameter("add.k1", "Gain of upper input", 41, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("add.k2", "Gain of lower input", 42, 1, 0.0,0.0,0.0,0,560)
DeclareOutput("CO2", "CO2 concentration [ppm] []", 7, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("re1.Q_flow", "Heat flow rate from port_a -> port_b [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("re1.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("re1.port_a.T", "Port temperature [K|degC]", "cair.T", 1, 1, 0, 4)
DeclareAlias2("re1.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "re1.Q_flow", 1, 5, 46, 132)
DeclareAlias2("re1.port_b.T", "Port temperature [K|degC]", "cint.T", 1, 1, 5, 4)
DeclareVariable("re1.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("re1.R", "Constant thermal resistance of material [K/W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("cint.C", "Heat capacity of element (= cp*m) [J/K]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareState("cint.T", "Temperature of element [K|degC]", 5, 293.15, 0.0,1E+100,\
300.0,0,560)
DeclareDerivative("cint.der(T)", "der(Temperature of element) [K/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("cint.der_T", "Time derivative of temperature (= der(T)) [K/s]", \
"cint.der(T)", 1, 6, 5, 0)
DeclareAlias2("cint.port.T", "Port temperature [K|degC]", "cint.T", 1, 1, 5, 4)
DeclareAlias2("cint.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "re1.Q_flow", 1, 5, 46, 132)
DeclareAlias2("PIDco2.u_s", "Connector of setpoint input signal", "CO2stp", 1, 2,\
 3, 0)
DeclareAlias2("PIDco2.u_m", "Connector of measurement input signal", \
"co2.balance.CO2ppmv_i", 1, 1, 4, 0)
DeclareAlias2("PIDco2.y", "Connector of actuator output signal", "scale.u", 1, 5,\
 34, 0)
DeclareVariable("PIDco2.controlError", "Control error (set point - measurement)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDco2.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDco2.k", "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("PIDco2.Ti", "Time constant of Integrator block [s]", 43, 0.5, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("PIDco2.Td", "Time constant of Derivative block [s]", 44, 0.1, \
0.0,1E+100,0.0,0,560)
DeclareParameter("PIDco2.yMax", "Upper limit of output", 45, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.yMin", "Lower limit of output", 46, -100, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.wp", "Set-point weight for Proportional block (0..1)", 47,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDco2.wd", "Set-point weight for Derivative block (0..1)", 48,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDco2.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 49, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("PIDco2.Nd", "The higher Nd, the more ideal the derivative block",\
 50, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("PIDco2.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("PIDco2.limitsAtInit", "= false, if limits are ignored during initialization [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("PIDco2.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 51, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.xd_start", "Initial or guess value for state of derivative block",\
 52, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.y_start", "Initial value of output", 53, 0, 0.0,0.0,0.0,\
0,560)
DeclareVariable("PIDco2.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDco2.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("PIDco2.addP.u1", "Connector of Real input signal 1", "CO2stp", 1,\
 2, 3, 0)
DeclareAlias2("PIDco2.addP.u2", "Connector of Real input signal 2", \
"co2.balance.CO2ppmv_i", 1, 1, 4, 0)
DeclareVariable("PIDco2.addP.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PIDco2.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PIDco2.addP.k2", "Gain of lower input", 54, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.P.k", "Gain value multiplied with input signal [1]", 55,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDco2.P.u", "Input signal connector", "PIDco2.addP.y", 1, 5, 58,\
 0)
DeclareVariable("PIDco2.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDco2.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDco2.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDco2.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareParameter("PIDco2.addPID.k1", "Gain of upper input", 56, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.addPID.k2", "Gain of middle input", 57, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("PIDco2.addPID.k3", "Gain of lower input", 58, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDco2.addPID.u1", "Connector 1 of Real input signals", \
"PIDco2.P.y", 1, 5, 60, 0)
DeclareAlias2("PIDco2.addPID.u2", "Connector 2 of Real input signals", \
"PIDco2.Dzero.k", 1, 7, 59, 0)
DeclareAlias2("PIDco2.addPID.u3", "Connector 3 of Real input signals", \
"PIDco2.I.y", 1, 1, 6, 0)
DeclareAlias2("PIDco2.addPID.y", "Connector of Real output signals", \
"PIDco2.gainPID.u", 1, 5, 62, 0)
DeclareVariable("PIDco2.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDco2.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDco2.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDco2.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("PIDco2.limiter.u", "Connector of Real input signal", \
"PIDco2.gainPID.y", 1, 5, 63, 0)
DeclareAlias2("PIDco2.limiter.y", "Connector of Real output signal", "scale.u", 1,\
 5, 34, 0)
DeclareVariable("PIDco2.with_I", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("PIDco2.with_D", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("PIDco2.Dzero.k", "Constant output value", 59, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDco2.Dzero.y", "Connector of Real output signal", \
"PIDco2.Dzero.k", 1, 7, 59, 0)
DeclareVariable("PIDco2.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDco2.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDco2.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDco2.I.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareState("PIDco2.I.y", "Connector of Real output signal", 6, 0.0, 0.0,0.0,\
0.0,0,544)
DeclareDerivative("PIDco2.I.der(y)", "der(Connector of Real output signal)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareParameter("PIDco2.addI.k1", "Gain of upper input", 60, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.addI.k2", "Gain of middle input", 61, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.addI.k3", "Gain of lower input", 62, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDco2.addI.u1", "Connector 1 of Real input signals", "CO2stp", 1,\
 2, 3, 0)
DeclareAlias2("PIDco2.addI.u2", "Connector 2 of Real input signals", \
"co2.balance.CO2ppmv_i", 1, 1, 4, 0)
DeclareVariable("PIDco2.addI.u3", "Connector 3 of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("PIDco2.addI.y", "Connector of Real output signals", "PIDco2.I.u", 1,\
 5, 73, 0)
DeclareAlias2("PIDco2.addSat.u1", "Connector of Real input signal 1", "scale.u", 1,\
 5, 34, 0)
DeclareAlias2("PIDco2.addSat.u2", "Connector of Real input signal 2", \
"PIDco2.gainPID.y", 1, 5, 63, 0)
DeclareVariable("PIDco2.addSat.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PIDco2.addSat.k1", "Gain of upper input", 63, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDco2.addSat.k2", "Gain of lower input", 64, -1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("PIDco2.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("PIDco2.gainTrack.u", "Input signal connector", "PIDco2.addSat.y", 1,\
 5, 75, 0)
DeclareAlias2("PIDco2.gainTrack.y", "Output signal connector", "PIDco2.addI.u3", 1,\
 5, 74, 0)
DeclareAlias2("PIDt.u_s", "Connector of setpoint input signal [K]", \
"Tstp_cooling", 1, 2, 4, 0)
DeclareAlias2("PIDt.u_m", "Connector of measurement input signal [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt.y", "Connector of actuator output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PIDt.controlError", "Control error (set point - measurement) [K]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDt.k", "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("PIDt.Ti", "Time constant of Integrator block [s]", 65, 0.5, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("PIDt.Td", "Time constant of Derivative block [s]", 66, 0.1, \
0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt.yMax", "Upper limit of output", 67, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.yMin", "Lower limit of output", 68, -100, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.wp", "Set-point weight for Proportional block (0..1)", 69,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt.wd", "Set-point weight for Derivative block (0..1)", 70, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 71, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("PIDt.Nd", "The higher Nd, the more ideal the derivative block",\
 72, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("PIDt.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("PIDt.limitsAtInit", "= false, if limits are ignored during initialization [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("PIDt.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 73, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.xd_start", "Initial or guess value for state of derivative block",\
 74, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.y_start", "Initial value of output", 75, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("PIDt.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDt.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("PIDt.addP.u1", "Connector of Real input signal 1 [K]", \
"Tstp_cooling", 1, 2, 4, 0)
DeclareAlias2("PIDt.addP.u2", "Connector of Real input signal 2 [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt.addP.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PIDt.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PIDt.addP.k2", "Gain of lower input", 76, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.P.k", "Gain value multiplied with input signal [1]", 77, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt.P.u", "Input signal connector", "PIDt.addP.y", 1, 5, 85, 0)
DeclareVariable("PIDt.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("PIDt.addPID.k1", "Gain of upper input", 78, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.addPID.k2", "Gain of middle input", 79, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.addPID.k3", "Gain of lower input", 80, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt.addPID.u1", "Connector 1 of Real input signals", "PIDt.P.y", 1,\
 5, 87, 0)
DeclareAlias2("PIDt.addPID.u2", "Connector 2 of Real input signals", \
"PIDt.Dzero.k", 1, 7, 81, 0)
DeclareAlias2("PIDt.addPID.u3", "Connector 3 of Real input signals", "PIDt.I.y", 1,\
 1, 7, 0)
DeclareAlias2("PIDt.addPID.y", "Connector of Real output signals", \
"PIDt.gainPID.u", 1, 5, 89, 0)
DeclareVariable("PIDt.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDt.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDt.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDt.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("PIDt.limiter.u", "Connector of Real input signal", \
"PIDt.gainPID.y", 1, 5, 90, 0)
DeclareAlias2("PIDt.limiter.y", "Connector of Real output signal", "PIDt.y", 1, 5,\
 77, 0)
DeclareVariable("PIDt.with_I", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("PIDt.with_D", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("PIDt.Dzero.k", "Constant output value", 81, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt.Dzero.y", "Connector of Real output signal", "PIDt.Dzero.k", 1,\
 7, 81, 0)
DeclareVariable("PIDt.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDt.I.y_start", "Initial or guess value of output (= state)", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt.I.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("PIDt.I.y", "Connector of Real output signal", 7, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("PIDt.I.der(y)", "der(Connector of Real output signal)", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PIDt.addI.k1", "Gain of upper input", 82, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.addI.k2", "Gain of middle input", 83, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.addI.k3", "Gain of lower input", 84, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt.addI.u1", "Connector 1 of Real input signals [K]", \
"Tstp_cooling", 1, 2, 4, 0)
DeclareAlias2("PIDt.addI.u2", "Connector 2 of Real input signals [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt.addI.u3", "Connector 3 of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("PIDt.addI.y", "Connector of Real output signals", "PIDt.I.u", 1, 5,\
 100, 0)
DeclareAlias2("PIDt.addSat.u1", "Connector of Real input signal 1", "PIDt.y", 1,\
 5, 77, 0)
DeclareAlias2("PIDt.addSat.u2", "Connector of Real input signal 2", \
"PIDt.gainPID.y", 1, 5, 90, 0)
DeclareVariable("PIDt.addSat.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PIDt.addSat.k1", "Gain of upper input", 85, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt.addSat.k2", "Gain of lower input", 86, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("PIDt.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("PIDt.gainTrack.u", "Input signal connector", "PIDt.addSat.y", 1, 5,\
 102, 0)
DeclareAlias2("PIDt.gainTrack.y", "Output signal connector", "PIDt.addI.u3", 1, 5,\
 101, 0)
DeclareAlias2("PIDt1.u_s", "Connector of setpoint input signal [K]", \
"Tstp_heating", 1, 2, 5, 0)
DeclareAlias2("PIDt1.u_m", "Connector of measurement input signal [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt1.y", "Connector of actuator output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PIDt1.controlError", "Control error (set point - measurement) [K]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt1.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDt1.k", "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("PIDt1.Ti", "Time constant of Integrator block [s]", 87, 0.5, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("PIDt1.Td", "Time constant of Derivative block [s]", 88, 0.1, \
0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt1.yMax", "Upper limit of output", 89, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.yMin", "Lower limit of output", 90, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.wp", "Set-point weight for Proportional block (0..1)", 91,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt1.wd", "Set-point weight for Derivative block (0..1)", 92,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("PIDt1.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 93, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("PIDt1.Nd", "The higher Nd, the more ideal the derivative block",\
 94, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("PIDt1.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("PIDt1.limitsAtInit", "= false, if limits are ignored during initialization [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("PIDt1.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 95, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.xd_start", "Initial or guess value for state of derivative block",\
 96, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.y_start", "Initial value of output", 97, 0, 0.0,0.0,0.0,\
0,560)
DeclareVariable("PIDt1.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDt1.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("PIDt1.addP.u1", "Connector of Real input signal 1 [K]", \
"Tstp_heating", 1, 2, 5, 0)
DeclareAlias2("PIDt1.addP.u2", "Connector of Real input signal 2 [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt1.addP.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PIDt1.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PIDt1.addP.k2", "Gain of lower input", 98, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.P.k", "Gain value multiplied with input signal [1]", 99,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt1.P.u", "Input signal connector", "PIDt1.addP.y", 1, 5, 112, 0)
DeclareVariable("PIDt1.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt1.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt1.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PIDt1.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("PIDt1.addPID.k1", "Gain of upper input", 100, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.addPID.k2", "Gain of middle input", 101, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("PIDt1.addPID.k3", "Gain of lower input", 102, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt1.addPID.u1", "Connector 1 of Real input signals", \
"PIDt1.P.y", 1, 5, 114, 0)
DeclareAlias2("PIDt1.addPID.u2", "Connector 2 of Real input signals", \
"PIDt1.Dzero.k", 1, 7, 103, 0)
DeclareAlias2("PIDt1.addPID.u3", "Connector 3 of Real input signals", \
"PIDt1.I.y", 1, 1, 8, 0)
DeclareAlias2("PIDt1.addPID.y", "Connector of Real output signals", \
"PIDt1.gainPID.u", 1, 5, 116, 0)
DeclareVariable("PIDt1.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDt1.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("PIDt1.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("PIDt1.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("PIDt1.limiter.u", "Connector of Real input signal", \
"PIDt1.gainPID.y", 1, 5, 117, 0)
DeclareAlias2("PIDt1.limiter.y", "Connector of Real output signal", "PIDt1.y", 1,\
 5, 104, 0)
DeclareVariable("PIDt1.with_I", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("PIDt1.with_D", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("PIDt1.Dzero.k", "Constant output value", 103, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt1.Dzero.y", "Connector of Real output signal", \
"PIDt1.Dzero.k", 1, 7, 103, 0)
DeclareVariable("PIDt1.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt1.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PIDt1.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PIDt1.I.u", "Connector of Real input signal", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareState("PIDt1.I.y", "Connector of Real output signal", 8, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("PIDt1.I.der(y)", "der(Connector of Real output signal)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareParameter("PIDt1.addI.k1", "Gain of upper input", 104, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.addI.k2", "Gain of middle input", 105, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.addI.k3", "Gain of lower input", 106, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PIDt1.addI.u1", "Connector 1 of Real input signals [K]", \
"Tstp_heating", 1, 2, 5, 0)
DeclareAlias2("PIDt1.addI.u2", "Connector 2 of Real input signals [K]", "cair.T", 1,\
 1, 0, 0)
DeclareVariable("PIDt1.addI.u3", "Connector 3 of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("PIDt1.addI.y", "Connector of Real output signals", "PIDt1.I.u", 1,\
 5, 127, 0)
DeclareAlias2("PIDt1.addSat.u1", "Connector of Real input signal 1", "PIDt1.y", 1,\
 5, 104, 0)
DeclareAlias2("PIDt1.addSat.u2", "Connector of Real input signal 2", \
"PIDt1.gainPID.y", 1, 5, 117, 0)
DeclareVariable("PIDt1.addSat.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PIDt1.addSat.k1", "Gain of upper input", 107, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PIDt1.addSat.k2", "Gain of lower input", 108, -1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("PIDt1.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("PIDt1.gainTrack.u", "Input signal connector", "PIDt1.addSat.y", 1,\
 5, 129, 0)
DeclareAlias2("PIDt1.gainTrack.y", "Output signal connector", "PIDt1.addI.u3", 1,\
 5, 128, 0)
DeclareInput("Tstp_heating", "Indoor temperature setpoint [degC] [K:#(prefix=input)]",\
 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("add1.u1", "Connector of Real input signal 1", "PIDt.y", 1, 5, 77,\
 0)
DeclareAlias2("add1.u2", "Connector of Real input signal 2", "PIDt1.y", 1, 5, 104,\
 0)
DeclareAlias2("add1.y", "Connector of Real output signal", "scale1.u", 1, 5, 37,\
 0)
DeclareParameter("add1.k1", "Gain of upper input", 109, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("add1.k2", "Gain of lower input", 110, 1, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0, 3);
DoRemember_(DYNX(F_,5), 0, 4);
DoRemember_(DYNX(F_,4), 0.0, 0);
DoRemember_(DYNX(W_,0), 0.0, 1);
DoRemember_(DYNX(W_,46), 0.0, 2);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionEnd()
